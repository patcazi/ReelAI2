import fetch from 'cross-fetch';
import FormData from 'form-data';
import { API_KEY_HEADER } from "./constants.mjs";
import * as Errors from "./error.mjs";
import { convertKeysToCamelCase, isBunEnv } from "./util.mjs";
export class APIClient {
    constructor({ baseUrl, apiKey }) {
        this.baseUrl = baseUrl;
        this.apiKey = apiKey;
    }
    async _request(method, endpoint, { params, body, skipCamelKeys, ...options } = {}) {
        const url = new URL(endpoint, this.baseUrl);
        if (params) {
            Object.keys(params).forEach((key) => url.searchParams.append(key, params[key]));
        }
        let headers = {
            [API_KEY_HEADER]: this.apiKey,
            ...options.headers,
        };
        // Bun will natively append headers like Content-Type, Content-Length, etc. so doesn't need to set them manually.
        if (!isBunEnv() && body) {
            if (body instanceof FormData) {
                if (typeof body.getHeaders === 'function') {
                    headers = {
                        ...headers,
                        ...body.getHeaders(),
                    };
                }
            }
            else {
                headers['content-type'] = 'application/json';
                body = JSON.stringify(body);
            }
        }
        const config = {
            ...options,
            method,
            headers,
            body,
        };
        const isStreamRequest = (params && params.stream === true) || (body && body.stream === true);
        try {
            const response = await fetch(url, config);
            const contentType = response.headers.get('Content-Type');
            let body = null;
            if (isStreamRequest) {
                body = response.body;
            }
            else if (contentType && contentType.includes('application/json')) {
                const rawBody = await response.json();
                body = convertKeysToCamelCase(rawBody, skipCamelKeys);
            }
            else {
                body = await response.text();
            }
            handleResponse(response, body, config);
            return body;
        }
        catch (error) {
            if (error.code === 'ENOTFOUND') {
                throw new Errors.APIConnectionError('API Connection Error', error);
            }
            if (error.type === 'request-timeout') {
                throw new Errors.APITimeoutError('API Timeout Error', error);
            }
            if (error instanceof Error) {
                throw error;
            }
            else {
                throw new Errors.APIError('An unknown error occurred');
            }
        }
    }
    async _get(endpoint, params, options = {}) {
        return (await this._request('GET', endpoint, { ...options, params }));
    }
    async _post(endpoint, data, options = {}) {
        return (await this._request('POST', endpoint, { ...options, body: data }));
    }
    async _patch(endpoint, data, options = {}) {
        return (await this._request('PATCH', endpoint, { ...options, body: data }));
    }
    async _put(endpoint, data, options = {}) {
        return (await this._request('PUT', endpoint, { ...options, body: data }));
    }
    async _delete(endpoint, options = {}) {
        return (await this._request('DELETE', endpoint, options));
    }
}
export function handleResponse(response, body, request) {
    if (!response.ok) {
        const message = body && body.message ? body.message : response.statusText;
        const headers = response.headers;
        if (response.status >= 400 && response.status < 500) {
            switch (response.status) {
                case 400:
                    throw new Errors.BadRequestError(message, response.status, body, headers, request);
                case 401:
                    throw new Errors.UnauthorizedError(message, response.status, body, headers, request);
                case 403:
                    throw new Errors.ForbiddenError(message, response.status, body, headers, request);
                case 404:
                    throw new Errors.NotFoundError(message, response.status, body, headers, request);
                case 405:
                    throw new Errors.MethodNotAllowedError(message, response.status, body, headers, request);
                case 409:
                    throw new Errors.ConflictError(message, response.status, body, headers, request);
                case 429:
                    throw new Errors.TooManyRequestsError(message, response.status, body, headers, request);
                default:
                    throw new Errors.APIError(message, response.status, body, headers, request);
            }
        }
        else if (response.status >= 500) {
            throw new Errors.InternalServerError(message, response.status, body, headers, request);
        }
        throw new Errors.APIError(message, response.status, body, headers, request);
    }
}
//# sourceMappingURL=core.mjs.map