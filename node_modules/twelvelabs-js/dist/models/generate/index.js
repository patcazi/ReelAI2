"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenerateTextStreamResult = void 0;
class GenerateTextStreamResult {
    constructor(stream) {
        this.texts = [];
        this.aggregatedText = '';
        this.stream = stream;
        this.id = '';
    }
    async *[Symbol.asyncIterator]() {
        const reader = this.stream.getReader();
        const decoder = new TextDecoder('utf-8');
        let chunk = '';
        while (true) {
            const { done, value } = await reader.read();
            if (done)
                break;
            if (value) {
                // Decode the current chunk and concatenate it to the previous chunks
                chunk += decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');
                // Store the last incomplete line back into chunk
                chunk = lines.pop();
                for (const line of lines) {
                    if (!line)
                        continue;
                    const event = JSON.parse(line);
                    switch (event.event_type) {
                        case 'stream_start':
                            this.id = event.metadata?.generation_id || '';
                            break;
                        case 'stream_error':
                            throw new Error(event.error.message);
                        case 'text_generation':
                            this.texts.push(event.text);
                            this.aggregatedText += event.text;
                            yield event.text;
                            break;
                        case 'stream_end':
                        default:
                            break;
                    }
                }
            }
        }
        // Process any remaining chunk that wasn't completed in the loop
        if (chunk) {
            const event = JSON.parse(chunk);
            if (event.event_type === 'text_generation') {
                this.texts.push(event.text);
                this.aggregatedText += event.text;
                yield event.text;
            }
        }
    }
}
exports.GenerateTextStreamResult = GenerateTextStreamResult;
//# sourceMappingURL=index.js.map