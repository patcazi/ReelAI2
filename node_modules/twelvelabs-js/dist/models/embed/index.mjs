export class Embedding {
    constructor(data) {
        this.segments = data.segments?.map((v) => new SegmentEmbedding(v));
        this.errorMessage = data.errorMessage;
        this.metadata = data.metadata;
    }
}
export class SegmentEmbedding {
    constructor(data) {
        this.embeddingsFloat = data.float;
        this.startOffsetSec = data.startOffsetSec;
        this.endOffsetSec = data.endOffsetSec;
        this.embeddingScope = data.embeddingScope;
    }
}
export class CreateEmbeddingsResult {
    constructor(data) {
        this.modelName = data.modelName;
        this.textEmbedding = data.textEmbedding ? new Embedding(data.textEmbedding) : undefined;
        this.imageEmbedding = data.imageEmbedding ? new Embedding(data.imageEmbedding) : undefined;
        this.videoEmbedding = data.videoEmbedding ? new Embedding(data.videoEmbedding) : undefined;
        this.audioEmbedding = data.audioEmbedding ? new Embedding(data.audioEmbedding) : undefined;
    }
}
export class EmbeddingsTaskStatus {
    constructor(data) {
        this.id = data.id;
        this.modelName = data.modelName;
        this.status = data.status;
        this.videoEmbedding = data.videoEmbedding ? new Embedding(data.videoEmbedding) : undefined;
    }
}
export class EmbeddingsTask {
    constructor(resource, data) {
        this._resource = resource;
        this.id = data.id;
        this.modelName = data.modelName;
        this.status = data.status;
        this.videoEmbedding = data.videoEmbedding ? new Embedding(data.videoEmbedding) : undefined;
        this.createdAt = data.createdAt;
    }
    async retrieve(options = {}) {
        return await this._resource.retrieve(this.id, options);
    }
    async getStatus(options = {}) {
        const { status } = await this._resource.status(this.id, options);
        return status;
    }
    async waitForDone(sleepInterval = 5000, callback) {
        const isDone = () => this.status === 'ready' || this.status === 'failed';
        if (sleepInterval <= 0) {
            throw new Error('sleepInterval must be greater than 0');
        }
        while (!isDone()) {
            await this.sleep(sleepInterval);
            try {
                this.status = await this.getStatus();
            }
            catch (err) {
                console.warn(`Retrieving status failed: ${err.message}, retrying..`);
                continue;
            }
            if (callback) {
                callback(this);
            }
        }
        return this.status;
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
export class EmbeddingsTaskListWithPagination {
    constructor(resource, originParams, data, pageInfo) {
        this._resource = resource;
        this._originParams = originParams;
        this.data = data.map((v) => new EmbeddingsTask(resource, v));
        this.pageInfo = pageInfo;
    }
    async next() {
        if (this.pageInfo.page >= this.pageInfo.totalPage) {
            return null;
        }
        const params = { ...this._originParams };
        params.page = this.pageInfo.page + 1;
        const res = await this._resource.listPagination(params);
        this.pageInfo = res.pageInfo;
        return res.data;
    }
}
//# sourceMappingURL=index.mjs.map