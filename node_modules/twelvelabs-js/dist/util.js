"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackStream = exports.attachFormFile = exports.FormDataImpl = exports.isBunEnv = exports.handleComparisonParams = exports.removeUndefinedValues = exports.convertKeysToSnakeCase = exports.convertKeysToCamelCase = void 0;
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
// In Node, use the Node-specific "form-data" package,
// but in Bun we use the global FormData.
const form_data_1 = __importDefault(require("form-data"));
// Converts object keys from snake_case or leading underscore format to camelCase.
// This function is recursive, so it works on nested objects and arrays of objects as well.
//
// Examples:
// 1. Converting simple object keys:
//    Input: {"first_name": "John", "last_name": "Doe"}
//    Output: {"firstName": "John", "lastName": "Doe"}
//
// 2. Handling keys with leading underscores:
//    Input: {"_id": 123, "user_name": "johndoe"}
//    Output: {"id": 123, "userName": "johndoe"}
//
// 3. Working with nested objects:
//    Input: {"user_details": {"first_name": "John", "last_name": "Doe"}}
//    Output: {"userDetails": {"firstName": "John", "lastName": "Doe"}}
//
// 4. Processing arrays of objects:
//    Input: [{"user_name": "johndoe"}, {"user_name": "janedoe"}]
//    Output: [{"userName": "johndoe"}, {"userName": "janedoe"}]
function convertKeysToCamelCase(obj, skipKeys) {
    if (Array.isArray(obj)) {
        return obj.map((v) => convertKeysToCamelCase(v));
    }
    else if (obj !== null && obj.constructor === Object) {
        return Object.keys(obj).reduce((result, key) => {
            // Skip converting keys by `skipKeys`
            if (skipKeys?.includes(key)) {
                return { ...result, [key]: obj[key] };
            }
            // Check if key starts with "_"
            if (key.startsWith('_')) {
                // If so, remove the underscore and use the rest of the key as is
                const newKey = key.substring(1);
                return {
                    ...result,
                    [newKey]: convertKeysToCamelCase(obj[key]),
                };
            }
            else {
                // Use the existing replacement logic for other keys
                const camelCaseKey = key.replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace('-', '').replace('_', ''));
                return {
                    ...result,
                    [camelCaseKey]: convertKeysToCamelCase(obj[key]),
                };
            }
        }, {});
    }
    return obj;
}
exports.convertKeysToCamelCase = convertKeysToCamelCase;
// Convert keys of an object from camelCase to snake_case, always applying deeply
function convertKeysToSnakeCase(obj) {
    if (Array.isArray(obj)) {
        return obj.map((item) => convertKeysToSnakeCase(item)); // Recursively apply to array elements
    }
    else if (obj !== null && typeof obj === 'object' && !(obj instanceof Date)) {
        return Object.keys(obj).reduce((acc, key) => {
            const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
            acc[snakeKey] = convertKeysToSnakeCase(obj[key]); // Recursively apply to nested objects
            return acc;
        }, {});
    }
    return obj;
}
exports.convertKeysToSnakeCase = convertKeysToSnakeCase;
function removeUndefinedValues(obj) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (value !== undefined) {
            acc[key] = value;
        }
        return acc;
    }, {});
}
exports.removeUndefinedValues = removeUndefinedValues;
function handleComparisonParams(params, key, value) {
    if (typeof value === 'object') {
        for (const op in value) {
            if (value.hasOwnProperty(op)) {
                const paramKey = `${key}[${op}]`;
                params[paramKey] = value[op];
            }
        }
        params[key] = undefined;
    }
    else {
        params[key] = value;
    }
}
exports.handleComparisonParams = handleComparisonParams;
function isBunEnv() {
    return typeof globalThis.Bun !== 'undefined';
}
exports.isBunEnv = isBunEnv;
exports.FormDataImpl = isBunEnv() ? globalThis.FormData : form_data_1.default;
function attachFormFile(formData, formKey, file) {
    const isBun = isBunEnv();
    if (typeof file === 'string') {
        const filePath = path_1.default.resolve(file);
        if (!fs.existsSync(filePath)) {
            throw new Error('File does not exist');
        }
        const fileName = path_1.default.basename(filePath);
        if (isBun) {
            const fileBuffer = fs.readFileSync(filePath);
            const blob = new Blob([fileBuffer], { type: 'application/octet-stream' });
            formData.append(formKey, blob, fileName);
        }
        else {
            const fileStream = fs.createReadStream(filePath);
            formData.append(formKey, fileStream, fileName);
        }
    }
    else if (file instanceof fs.ReadStream) {
        const filePath = file.path;
        if (!fs.existsSync(filePath)) {
            throw new Error('File does not exist');
        }
        const resolvedPath = typeof filePath === 'string' ? filePath : filePath.toString();
        const fileName = path_1.default.basename(resolvedPath);
        if (isBun) {
            const fileBuffer = fs.readFileSync(resolvedPath);
            const blob = new Blob([fileBuffer], { type: 'application/octet-stream' });
            formData.append(formKey, blob, fileName);
        }
        else {
            formData.append(formKey, file);
        }
    }
    else if (Buffer.isBuffer(file)) {
        if (isBun) {
            const blob = new Blob([file], { type: 'application/octet-stream' });
            formData.append(formKey, blob, 'file');
        }
        else {
            formData.append(formKey, file, 'file');
        }
    }
}
exports.attachFormFile = attachFormFile;
// Splits a chunk into smaller chunks of a specified size.
const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
    }
};
// Reads bytes from an AsyncIterable and splits them into smaller chunks.
const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of iterable) {
        yield* streamChunk(chunk, chunkSize);
    }
};
// Tracks the stream and processes it in smaller chunks.
// The default chunk size is set to 32KB (32 * 1024 bytes). This chunk size is chosen
// to balance between memory usage and processing efficiency.
const trackStream = (stream, chunkSize = 32 * 1024) => {
    const iterator = readBytes(stream, chunkSize);
    return new ReadableStream({
        type: 'bytes',
        async pull(controller) {
            // Read the next chunk from the iterator
            const { done, value } = await iterator.next();
            if (done) {
                // If the iterator is done, close the stream
                controller.close();
                return;
            }
            // Enqueue the chunk into the stream
            controller.enqueue(new Uint8Array(value || []));
        },
    });
};
exports.trackStream = trackStream;
//# sourceMappingURL=util.js.map