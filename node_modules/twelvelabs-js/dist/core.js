"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleResponse = exports.APIClient = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const form_data_1 = __importDefault(require("form-data"));
const constants_1 = require("./constants.js");
const Errors = __importStar(require("./error.js"));
const util_1 = require("./util.js");
class APIClient {
    constructor({ baseUrl, apiKey }) {
        this.baseUrl = baseUrl;
        this.apiKey = apiKey;
    }
    async _request(method, endpoint, { params, body, skipCamelKeys, ...options } = {}) {
        const url = new URL(endpoint, this.baseUrl);
        if (params) {
            Object.keys(params).forEach((key) => url.searchParams.append(key, params[key]));
        }
        let headers = {
            [constants_1.API_KEY_HEADER]: this.apiKey,
            ...options.headers,
        };
        // Bun will natively append headers like Content-Type, Content-Length, etc. so doesn't need to set them manually.
        if (!(0, util_1.isBunEnv)() && body) {
            if (body instanceof form_data_1.default) {
                if (typeof body.getHeaders === 'function') {
                    headers = {
                        ...headers,
                        ...body.getHeaders(),
                    };
                }
            }
            else {
                headers['content-type'] = 'application/json';
                body = JSON.stringify(body);
            }
        }
        const config = {
            ...options,
            method,
            headers,
            body,
        };
        const isStreamRequest = (params && params.stream === true) || (body && body.stream === true);
        try {
            const response = await (0, cross_fetch_1.default)(url, config);
            const contentType = response.headers.get('Content-Type');
            let body = null;
            if (isStreamRequest) {
                body = response.body;
            }
            else if (contentType && contentType.includes('application/json')) {
                const rawBody = await response.json();
                body = (0, util_1.convertKeysToCamelCase)(rawBody, skipCamelKeys);
            }
            else {
                body = await response.text();
            }
            handleResponse(response, body, config);
            return body;
        }
        catch (error) {
            if (error.code === 'ENOTFOUND') {
                throw new Errors.APIConnectionError('API Connection Error', error);
            }
            if (error.type === 'request-timeout') {
                throw new Errors.APITimeoutError('API Timeout Error', error);
            }
            if (error instanceof Error) {
                throw error;
            }
            else {
                throw new Errors.APIError('An unknown error occurred');
            }
        }
    }
    async _get(endpoint, params, options = {}) {
        return (await this._request('GET', endpoint, { ...options, params }));
    }
    async _post(endpoint, data, options = {}) {
        return (await this._request('POST', endpoint, { ...options, body: data }));
    }
    async _patch(endpoint, data, options = {}) {
        return (await this._request('PATCH', endpoint, { ...options, body: data }));
    }
    async _put(endpoint, data, options = {}) {
        return (await this._request('PUT', endpoint, { ...options, body: data }));
    }
    async _delete(endpoint, options = {}) {
        return (await this._request('DELETE', endpoint, options));
    }
}
exports.APIClient = APIClient;
function handleResponse(response, body, request) {
    if (!response.ok) {
        const message = body && body.message ? body.message : response.statusText;
        const headers = response.headers;
        if (response.status >= 400 && response.status < 500) {
            switch (response.status) {
                case 400:
                    throw new Errors.BadRequestError(message, response.status, body, headers, request);
                case 401:
                    throw new Errors.UnauthorizedError(message, response.status, body, headers, request);
                case 403:
                    throw new Errors.ForbiddenError(message, response.status, body, headers, request);
                case 404:
                    throw new Errors.NotFoundError(message, response.status, body, headers, request);
                case 405:
                    throw new Errors.MethodNotAllowedError(message, response.status, body, headers, request);
                case 409:
                    throw new Errors.ConflictError(message, response.status, body, headers, request);
                case 429:
                    throw new Errors.TooManyRequestsError(message, response.status, body, headers, request);
                default:
                    throw new Errors.APIError(message, response.status, body, headers, request);
            }
        }
        else if (response.status >= 500) {
            throw new Errors.InternalServerError(message, response.status, body, headers, request);
        }
        throw new Errors.APIError(message, response.status, body, headers, request);
    }
}
exports.handleResponse = handleResponse;
//# sourceMappingURL=core.js.map