import * as fs from 'fs';
import path from 'path';
import FormDataNode from 'form-data';
// Converts object keys from snake_case or leading underscore format to camelCase.
// This function is recursive, so it works on nested objects and arrays of objects as well.
//
// Examples:
// 1. Converting simple object keys:
//    Input: {"first_name": "John", "last_name": "Doe"}
//    Output: {"firstName": "John", "lastName": "Doe"}
//
// 2. Handling keys with leading underscores:
//    Input: {"_id": 123, "user_name": "johndoe"}
//    Output: {"id": 123, "userName": "johndoe"}
//
// 3. Working with nested objects:
//    Input: {"user_details": {"first_name": "John", "last_name": "Doe"}}
//    Output: {"userDetails": {"firstName": "John", "lastName": "Doe"}}
//
// 4. Processing arrays of objects:
//    Input: [{"user_name": "johndoe"}, {"user_name": "janedoe"}]
//    Output: [{"userName": "johndoe"}, {"userName": "janedoe"}]
export function convertKeysToCamelCase(obj, skipKeys) {
    if (Array.isArray(obj)) {
        return obj.map((v) => convertKeysToCamelCase(v));
    }
    else if (obj !== null && obj.constructor === Object) {
        return Object.keys(obj).reduce((result, key) => {
            // Skip converting keys by `skipKeys`
            if (skipKeys?.includes(key)) {
                return { ...result, [key]: obj[key] };
            }
            // Check if key starts with "_"
            if (key.startsWith('_')) {
                // If so, remove the underscore and use the rest of the key as is
                const newKey = key.substring(1);
                return {
                    ...result,
                    [newKey]: convertKeysToCamelCase(obj[key]),
                };
            }
            else {
                // Use the existing replacement logic for other keys
                const camelCaseKey = key.replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace('-', '').replace('_', ''));
                return {
                    ...result,
                    [camelCaseKey]: convertKeysToCamelCase(obj[key]),
                };
            }
        }, {});
    }
    return obj;
}
// Convert keys of an object from camelCase to snake_case, always applying deeply
export function convertKeysToSnakeCase(obj) {
    if (Array.isArray(obj)) {
        return obj.map((item) => convertKeysToSnakeCase(item)); // Recursively apply to array elements
    }
    else if (obj !== null && typeof obj === 'object' && !(obj instanceof Date)) {
        return Object.keys(obj).reduce((acc, key) => {
            const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
            acc[snakeKey] = convertKeysToSnakeCase(obj[key]); // Recursively apply to nested objects
            return acc;
        }, {});
    }
    return obj;
}
export function removeUndefinedValues(obj) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (value !== undefined) {
            acc[key] = value;
        }
        return acc;
    }, {});
}
export function handleComparisonParams(params, key, value) {
    if (typeof value === 'object') {
        for (const op in value) {
            if (value.hasOwnProperty(op)) {
                const paramKey = `${key}[${op}]`;
                params[paramKey] = value[op];
            }
        }
        params[key] = undefined;
    }
    else {
        params[key] = value;
    }
}
export function isBunEnv() {
    return typeof globalThis.Bun !== 'undefined';
}
export const FormDataImpl = isBunEnv() ? globalThis.FormData : FormDataNode;
export function attachFormFile(formData, formKey, file) {
    const isBun = isBunEnv();
    if (typeof file === 'string') {
        const filePath = path.resolve(file);
        if (!fs.existsSync(filePath)) {
            throw new Error('File does not exist');
        }
        const fileName = path.basename(filePath);
        if (isBun) {
            const fileBuffer = fs.readFileSync(filePath);
            const blob = new Blob([fileBuffer], { type: 'application/octet-stream' });
            formData.append(formKey, blob, fileName);
        }
        else {
            const fileStream = fs.createReadStream(filePath);
            formData.append(formKey, fileStream, fileName);
        }
    }
    else if (file instanceof fs.ReadStream) {
        const filePath = file.path;
        if (!fs.existsSync(filePath)) {
            throw new Error('File does not exist');
        }
        const resolvedPath = typeof filePath === 'string' ? filePath : filePath.toString();
        const fileName = path.basename(resolvedPath);
        if (isBun) {
            const fileBuffer = fs.readFileSync(resolvedPath);
            const blob = new Blob([fileBuffer], { type: 'application/octet-stream' });
            formData.append(formKey, blob, fileName);
        }
        else {
            formData.append(formKey, file);
        }
    }
    else if (Buffer.isBuffer(file)) {
        if (isBun) {
            const blob = new Blob([file], { type: 'application/octet-stream' });
            formData.append(formKey, blob, 'file');
        }
        else {
            formData.append(formKey, file, 'file');
        }
    }
}
// Splits a chunk into smaller chunks of a specified size.
const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
    }
};
// Reads bytes from an AsyncIterable and splits them into smaller chunks.
const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of iterable) {
        yield* streamChunk(chunk, chunkSize);
    }
};
// Tracks the stream and processes it in smaller chunks.
// The default chunk size is set to 32KB (32 * 1024 bytes). This chunk size is chosen
// to balance between memory usage and processing efficiency.
export const trackStream = (stream, chunkSize = 32 * 1024) => {
    const iterator = readBytes(stream, chunkSize);
    return new ReadableStream({
        type: 'bytes',
        async pull(controller) {
            // Read the next chunk from the iterator
            const { done, value } = await iterator.next();
            if (done) {
                // If the iterator is done, close the stream
                controller.close();
                return;
            }
            // Enqueue the chunk into the stream
            controller.enqueue(new Uint8Array(value || []));
        },
    });
};
//# sourceMappingURL=util.mjs.map